/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import { clientsClaim } from 'workbox-core'
import { createHandlerBoundToURL, precacheAndRoute } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'

declare const self: ServiceWorkerGlobalScope

clientsClaim()

// Precache the relevant assets generated by the build process.
const manifest = self.__WB_MANIFEST.filter((entry) => {
  const url = typeof entry === 'string' ? entry : entry.url

  /**
   * We don't want to cache index.html because it delays the propagation of new content.
   * The culprit is cloudflare cached the resolve of url to ipfs link for more than several hours,
   * i.e. the url persists pointing to an old ipfs cid even though _dnslink TXT record is updated,
   * and cloudflare offers nowhere to purge such cache.
   *
   * With that, for an old user to be serviced new content, he needs to
   * 1. wait for the service-worker.js brower cache TTL to expire
   * 2. wait for the service-worker.js cloudflare edge's cache to expire
   * 3. wait for the service-worker.js cloudflare url->ipfs resolve cache to expire
   * 4. reopen the site to kickstart new service worker version
   *
   * To ease the problem a little bit, we just stop caching index.html.
   * The app cannot work without internet connection anyway.
   */
  if (url === './index.html') {
    return false
  }

  // If this is a language file, skip. They are compiled elsewhere.
  if (url.endsWith('.po')) {
    return false
  }

  // If this isn't a var woff2 font, skip. Modern browsers only need var fonts.
  if (url.endsWith('.woff') || (url.endsWith('.woff2') && !url.includes('.var'))) {
    return false
  }

  return true
})
precacheAndRoute(manifest)

// Set up App Shell-style routing, so that navigation requests are fulfilled
// immediately with a local index.html shell. See
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')
registerRoute(({ request, url }: { request: Request; url: URL }) => {
  // If this isn't muffin.fi, skip. IPFS gateways may not have domain
  // separation, so they cannot use App Shell-style routing.
  if (url.hostname !== 'muffin.fi') {
    return false
  }

  // If this isn't a navigation, skip.
  if (request.mode !== 'navigate') {
    return false
  }

  // If this looks like a URL for a resource, skip.
  if (url.pathname.match(fileExtensionRegexp)) {
    return false
  }

  return true
}, createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html'))

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
//
// see
// - https://create-react-app.dev/docs/making-a-progressive-web-app/
// - https://jeffy.info/2018/10/10/sw-in-c-r-a.html
// - https://web.dev/service-worker-lifecycle/#waiting
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})
